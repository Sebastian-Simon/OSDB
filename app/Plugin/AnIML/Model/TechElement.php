<?php

/**
 * Class TechElement
 */

class TechElement extends AnimlAppModel
{
public $useTable = false;

/**
 * The root element of an AnIML Technique Definition document.  Techniques are typically categorized as either sample alteration, detection, or data post-processing.  Each document defines and constrains how ExperimentSteps and Sample definitions are to be filled for its respective technique in an AnIML document.
 */
public function Technique()
{
$ele['type']='TechniqueType';
$ele['ref'][0]=['name'=>'literatureReferenceIDUsage','refer'=>'literatureReferenceID'];
$ele['ref'][0]['sel']=['xpath'=>'.//Documentation'];
$ele['ref'][0]['fld']=['xpath'=>'@literatureReferenceID'];
$ele['uni'][0]=['name'=>'sampleRoleName'];
$ele['uni'][0]['sel']=['xpath'=>'SampleRole'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
$ele['uni'][1]=['name'=>'resultBlueprintName'];
$ele['uni'][1]['sel']=['xpath'=>'ResultBlueprint'];
$ele['uni'][1]['fld']=['xpath'=>'@name'];
$ele['uni'][2]=['name'=>'literatureReferenceID'];
$ele['uni'][2]['sel']=['xpath'=>'Bibliography/LiteratureReference'];
$ele['uni'][2]['fld']=['xpath'=>'@literatureReferenceID'];
return $ele;
}

/**
 * For Extensions only. Specifies which Technique Definitions or Extensions can be extended using this Extension.
 */
public function ExtensionScope()
{
$ele['type']='ExtensionScopeType';
return $ele;
}

/**
 * Reference to a Technique Definition which can be extended using this Extension.
 */
public function ExtendedTechnique()
{
$ele['type']='ExtendedTechniqueType';
return $ele;
}

/**
 * Reference to an Extension which can be extended using this Extension.
 */
public function ExtendedExtension()
{
$ele['type']='ExtendedExtensionType';
return $ele;
}

/**
 * Definition of characteristics and role that the referenced Sample plays in the ExperimentStep.
 */
public function SampleRoleBlueprint()
{
$ele['type']='SampleRoleBlueprintType';
return $ele;
}

/**
 * Definition of characteristics and role that the referenced ExperimentStep plays in the ExperimentStep.
 */
public function ExperimentDataRoleBlueprint()
{
$ele['type']='ExperimentDataRoleBlueprintType';
return $ele;
}

/**
 * Description of the experimental method used.
 */
public function MethodBlueprint()
{
$ele['type']='MethodBlueprintType';
$ele['uni'][0]=['name'=>'methodCategoryName'];
$ele['uni'][0]['sel']=['xpath'=>'CategoryBlueprint'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
return $ele;
}

/**
 * Definition of a Result generated by the ExperimentStep.
 */
public function ResultBlueprint()
{
$ele['type']='ResultBlueprintType';
$ele['uni'][0]=['name'=>'resultCategoryName'];
$ele['uni'][0]['sel']=['xpath'=>'CategoryBlueprint'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
return $ele;
}

/**
 * Definition of SeriesSet that needs to be attached at this point.
 */
public function SeriesSetBlueprint()
{
$ele['type']='SeriesSetBlueprintType';
// SeriesBlueprint names must be unique per SeriesSetBlueprint.
$ele['uni'][0]=['name'=>'seriesName'];
$ele['uni'][0]['sel']=['xpath'=>'.//SeriesBlueprint'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
return $ele;
}

/**
 * Set of alternative Series which need to be attached to this SeriesSet.
 */
public function SeriesBlueprintChoice()
{
$ele['type']='SeriesBlueprintChoiceType';
return $ele;
}

/**
 * Definition of Series that needs to be attached to this SeriesSet.
 */
public function SeriesBlueprint()
{
$ele['type']='SeriesBlueprintType';
// A Quantity must be unique per SeriesBlueprint.
$ele['uni'][0]=['name'=>'quantityNameUniquePerSeriesBlueprint'];
$ele['uni'][0]['sel']=['xpath'=>'Quantity'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
return $ele;
}

/**
 * Collection of Parameters to be used on this hierarchy level.
 */
public function CategoryBlueprint()
{
$ele['type']='CategoryBlueprintType';
$ele['uni'][0]=['name'=>'parameterBlueprintName'];
$ele['uni'][0]['sel']=['xpath'=>'ParameterBlueprint'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
$ele['uni'][1]=['name'=>'subCategoryBlueprintName'];
$ele['uni'][1]['sel']=['xpath'=>'CategoryBlueprint'];
$ele['uni'][1]['fld']=['xpath'=>'@name'];
return $ele;
}

/**
 * Name-value pair to be stored in current Category.
 */
public function ParameterBlueprint()
{
$ele['type']='ParameterBlueprintType';
// A Quantity may not be listed multiple times per ParameterBlueprint.
$ele['uni'][0]=['name'=>'quantityNameUniquePerParameterBlueprint'];
$ele['uni'][0]['sel']=['xpath'=>'Quantity'];
$ele['uni'][0]['fld']=['xpath'=>'@name'];
return $ele;
}

/**
 * Description of the enclosing element.
 */
public function Documentation()
{
$ele['type']='DocumentationType';
return $ele;
}

/**
 * Set of literature references used in the documentation of this technique definition.
 */
public function Bibliography()
{
$ele['type']='BibliographyType';
return $ele;
}

/**
 * Literature reference cited from within the Documentation element.
 */
public function LiteratureReference()
{
$ele['type']='LiteratureReferenceType';
return $ele;
}

/**
 * Definition of an allowable Quantity and its associated Units.
 */
public function Quantity()
{
$ele['type']='QuantityType';
$ele['ref'][0]=['name'=>'allowedRangeUnitLabelKeyRef','refer'=>'unitLabelUniquePerQuantity'];
$ele['ref'][0]['sel']=['xpath'=>'AllowedRange'];
$ele['ref'][0]['fld']=['xpath'=>'@unit'];
$ele['uni'][0]=['name'=>'unitLabelUniquePerQuantity'];
$ele['uni'][0]['sel']=['xpath'=>'Unit'];
// A Quantity may not have multiple Units with the same label.
$ele['uni'][0]['fld']=['xpath'=>'@label'];
return $ele;
}

/**
 * Definition of a supported Scientific Unit.
 */
public function Unit()
{
$ele['type']='UnitType';
return $ele;
}

/**
 * Combination of SI Units used to represent Scientific Unit.
 */
public function SIUnit()
{
$ele['type']='SIUnitType';
return $ele;
}

/**
 * Permitted Values for Parameter. If not specified, the full range of the data type is allowed.
 */
public function AllowedValue()
{
$ele['type']='AllowedValueType';
return $ele;
}

/**
 * Allowed value range for a Parameter or Series.
 */
public function AllowedRange()
{
$ele['type']='AllowedRangeType';
return $ele;
}

/**
 * Lower range boundary; may be marked as inclusive or exclusive.
 */
public function Min()
{
$ele['type']='MinType';
return $ele;
}

/**
 * Upper range boundary; may be marked as inclusive or exclusive.
 */
public function Max()
{
$ele['type']='MaxType';
return $ele;
}

/**
 * Single 32-bit signed integer value.
 */
public function I()
{
$ele['type']='Int32Type';
return $ele;
}

/**
 * Single 64-bit signed integer value.
 */
public function L()
{
$ele['type']='Int64Type';
return $ele;
}

/**
 * Single 32-bit floating point value.
 */
public function F()
{
$ele['type']='Float32Type';
return $ele;
}

/**
 * Single 64-bit floating point value.
 */
public function D()
{
$ele['type']='Float64Type';
return $ele;
}

/**
 * Single string value.
 */
public function S()
{
$ele['type']='StringType';
return $ele;
}

/**
 * Single Boolean value.
 */
public function Boolean()
{
$ele['type']='BooleanType';
return $ele;
}

/**
 * Single ISO date and time value.
 */
public function DateTime()
{
$ele['type']='DateTimeType';
return $ele;
}

/**
 * Base64 binary encoded PNG image.
 */
public function PNG()
{
$ele['type']='PNGType';
return $ele;
}

/**
 * Value governed by a non-AnIML XML Schema.
 */
public function EmbeddedXML()
{
$ele['type']='EmbeddedXMLType';
return $ele;
}

/**
 * Value governed by the SVG DTD. Used to represent vector graphic images.
 */
public function SVG()
{
$ele['type']='SVGType';
return $ele;
}

}
?>